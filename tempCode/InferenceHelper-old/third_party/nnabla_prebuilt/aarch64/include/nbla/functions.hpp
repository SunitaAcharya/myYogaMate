// Copyright 2019,2020,2021 Sony Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - include/nbla/functions.hpp.tmpl
// - build-tools/code_generator/generate.py

#ifndef __NBLA_FUNCTIONS_HPP__
#define __NBLA_FUNCTIONS_HPP__
#include <vector>

#include <nbla/computation_graph/variable.hpp>
#include <nbla/context.hpp>
#include <nbla/global_context.hpp>
#include <nbla/communicator.hpp>

namespace nbla {
namespace functions {

NBLA_API vector<CgVariablePtr> affine(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis);
NBLA_API CgVariablePtr affine(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis);

NBLA_API vector<CgVariablePtr> rnn(Context &ctx, CgVariablePtr x, CgVariablePtr h, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, const string & nonlinearity, float dropout, bool bidirectional, bool training);
NBLA_API CgVariablePtr rnn(CgVariablePtr x, CgVariablePtr h, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, const string & nonlinearity, float dropout, bool bidirectional, bool training);

NBLA_API vector<CgVariablePtr> lstm(Context &ctx, CgVariablePtr x, CgVariablePtr h, CgVariablePtr c, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, float dropout, bool bidirectional, bool training);
NBLA_API CgVariablePtr lstm(CgVariablePtr x, CgVariablePtr h, CgVariablePtr c, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, float dropout, bool bidirectional, bool training);

NBLA_API vector<CgVariablePtr> gru(Context &ctx, CgVariablePtr x, CgVariablePtr h, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, float dropout, bool bidirectional, bool training);
NBLA_API CgVariablePtr gru(CgVariablePtr x, CgVariablePtr h, CgVariablePtr weight_l0, CgVariablePtr weight, CgVariablePtr bias, int num_layers, float dropout, bool bidirectional, bool training);

NBLA_API vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last);
NBLA_API CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last);

NBLA_API vector<CgVariablePtr> fused_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, CgVariablePtr z, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last, float decay_rate, float eps, bool batch_stat, const string & nonlinearity, const vector<float> & nonlinearity_args);
NBLA_API CgVariablePtr fused_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, CgVariablePtr z, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last, float decay_rate, float eps, bool batch_stat, const string & nonlinearity, const vector<float> & nonlinearity_args);

NBLA_API vector<CgVariablePtr> depthwise_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int multiplier);
NBLA_API CgVariablePtr depthwise_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int multiplier);

NBLA_API vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last, const vector<int> & output_padding);
NBLA_API CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, bool channel_last, const vector<int> & output_padding);

NBLA_API vector<CgVariablePtr> depthwise_deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int divisor);
NBLA_API CgVariablePtr depthwise_deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int divisor);

NBLA_API vector<CgVariablePtr> deformable_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr offset, CgVariablePtr mask, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, int deformable_group, bool channel_last);
NBLA_API CgVariablePtr deformable_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr offset, CgVariablePtr mask, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, int deformable_group, bool channel_last);

NBLA_API vector<CgVariablePtr> adaptive_separable_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr vertical_kernel, CgVariablePtr horizontal_kernel);
NBLA_API CgVariablePtr adaptive_separable_convolution(CgVariablePtr x, CgVariablePtr vertical_kernel, CgVariablePtr horizontal_kernel);

NBLA_API vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);
NBLA_API CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);

NBLA_API vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last, bool including_pad);
NBLA_API CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last, bool including_pad);

NBLA_API vector<CgVariablePtr> global_average_pooling(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr global_average_pooling(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);
NBLA_API CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);

NBLA_API vector<CgVariablePtr> unpooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, bool channel_last);
NBLA_API CgVariablePtr unpooling(CgVariablePtr x, const vector<int> & kernel, bool channel_last);

NBLA_API vector<CgVariablePtr> embed(Context &ctx, CgVariablePtr x0, CgVariablePtr w);
NBLA_API CgVariablePtr embed(CgVariablePtr x0, CgVariablePtr w);

NBLA_API vector<CgVariablePtr> roi_align(Context &ctx, CgVariablePtr input, CgVariablePtr boxes, const vector<int> & output_size, const vector<float> & spatial_scale, int sampling_ratio, bool channel_last);
NBLA_API CgVariablePtr roi_align(CgVariablePtr input, CgVariablePtr boxes, const vector<int> & output_size, const vector<float> & spatial_scale, int sampling_ratio, bool channel_last);

NBLA_API vector<CgVariablePtr> sigmoid(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr sigmoid(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> swish(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr swish(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> tanh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr tanh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> relu(Context &ctx, CgVariablePtr x, bool inplace);
NBLA_API CgVariablePtr relu(CgVariablePtr x, bool inplace);

NBLA_API vector<CgVariablePtr> leaky_relu(Context &ctx, CgVariablePtr x, float alpha, bool inplace);
NBLA_API CgVariablePtr leaky_relu(CgVariablePtr x, float alpha, bool inplace);

NBLA_API vector<CgVariablePtr> softmax(Context &ctx, CgVariablePtr x, int axis);
NBLA_API CgVariablePtr softmax(CgVariablePtr x, int axis);

NBLA_API vector<CgVariablePtr> log_softmax(Context &ctx, CgVariablePtr x, int axis);
NBLA_API CgVariablePtr log_softmax(CgVariablePtr x, int axis);

NBLA_API vector<CgVariablePtr> elu(Context &ctx, CgVariablePtr x, double alpha);
NBLA_API CgVariablePtr elu(CgVariablePtr x, double alpha);

NBLA_API vector<CgVariablePtr> selu(Context &ctx, CgVariablePtr x, double scale, double alpha);
NBLA_API CgVariablePtr selu(CgVariablePtr x, double scale, double alpha);

NBLA_API vector<CgVariablePtr> crelu(Context &ctx, CgVariablePtr x, int axis);
NBLA_API CgVariablePtr crelu(CgVariablePtr x, int axis);

NBLA_API vector<CgVariablePtr> celu(Context &ctx, CgVariablePtr x, double alpha, int axis);
NBLA_API CgVariablePtr celu(CgVariablePtr x, double alpha, int axis);

NBLA_API vector<CgVariablePtr> prelu(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, int base_axis);
NBLA_API CgVariablePtr prelu(CgVariablePtr x0, CgVariablePtr x1, int base_axis);

NBLA_API vector<CgVariablePtr> gelu(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr gelu(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> mish(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr mish(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> relu6(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr relu6(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> hard_sigmoid(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr hard_sigmoid(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> hard_tanh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr hard_tanh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> log_sigmoid(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr log_sigmoid(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> softplus(Context &ctx, CgVariablePtr x, double beta);
NBLA_API CgVariablePtr softplus(CgVariablePtr x, double beta);

NBLA_API vector<CgVariablePtr> softsign(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr softsign(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> tanh_shrink(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr tanh_shrink(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> sinc(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr sinc(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> fused_batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, CgVariablePtr z, const vector<int> & axes, float decay_rate, float eps, bool batch_stat, const string & nonlinearity);
NBLA_API CgVariablePtr fused_batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, CgVariablePtr z, const vector<int> & axes, float decay_rate, float eps, bool batch_stat, const string & nonlinearity);

NBLA_API vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, const vector<int> & axes, float decay_rate, float eps, bool batch_stat, bool no_scale, bool no_bias);
NBLA_API CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, const vector<int> & axes, float decay_rate, float eps, bool batch_stat, bool no_scale, bool no_bias);

NBLA_API vector<CgVariablePtr> group_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, int num_groups, int channel_axis, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);
NBLA_API CgVariablePtr group_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, int num_groups, int channel_axis, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);

NBLA_API vector<CgVariablePtr> instance_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, int channel_axis, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);
NBLA_API CgVariablePtr instance_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, int channel_axis, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);

NBLA_API vector<CgVariablePtr> layer_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);
NBLA_API CgVariablePtr layer_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, const vector<int> & batch_axis, float eps, bool no_scale, bool no_bias);

NBLA_API vector<CgVariablePtr> norm_normalization(Context &ctx, CgVariablePtr x, float p, const vector<int> & axes, float eps);
NBLA_API CgVariablePtr norm_normalization(CgVariablePtr x, float p, const vector<int> & axes, float eps);

NBLA_API vector<CgVariablePtr> sync_batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, const shared_ptr<Communicator> & comm, const string & group, const vector<int> & axes, float decay_rate, float eps, bool batch_stat);
NBLA_API CgVariablePtr sync_batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, const shared_ptr<Communicator> & comm, const string & group, const vector<int> & axes, float decay_rate, float eps, bool batch_stat);

NBLA_API vector<CgVariablePtr> tensor_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, const vector<int> & axes, float eps, bool no_scale, bool no_bias);
NBLA_API CgVariablePtr tensor_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, const vector<int> & axes, float eps, bool no_scale, bool no_bias);

NBLA_API vector<CgVariablePtr> weight_normalization(Context &ctx, CgVariablePtr w, CgVariablePtr g, int dim, float eps);
NBLA_API CgVariablePtr weight_normalization(CgVariablePtr w, CgVariablePtr g, int dim, float eps);

NBLA_API vector<CgVariablePtr> weight_standardization(Context &ctx, CgVariablePtr w, int channel_axis, float eps);
NBLA_API CgVariablePtr weight_standardization(CgVariablePtr w, int channel_axis, float eps);

NBLA_API vector<CgVariablePtr> spectral_norm(Context &ctx, CgVariablePtr w, CgVariablePtr u, int dim, int itr, float eps, bool test, bool output_u);
NBLA_API CgVariablePtr spectral_norm(CgVariablePtr w, CgVariablePtr u, int dim, int itr, float eps, bool test, bool output_u);

NBLA_API vector<CgVariablePtr> mean_subtraction(Context &ctx, CgVariablePtr x, CgVariablePtr rmean, CgVariablePtr t, int base_axis, bool update_running_mean);
NBLA_API CgVariablePtr mean_subtraction(CgVariablePtr x, CgVariablePtr rmean, CgVariablePtr t, int base_axis, bool update_running_mean);

NBLA_API vector<CgVariablePtr> clip_grad_by_value(Context &ctx, CgVariablePtr x, CgVariablePtr min, CgVariablePtr max);
NBLA_API CgVariablePtr clip_grad_by_value(CgVariablePtr x, CgVariablePtr min, CgVariablePtr max);

NBLA_API vector<CgVariablePtr> clip_grad_by_norm(Context &ctx, CgVariablePtr x, float clip_norm, const vector<int> & axes);
NBLA_API CgVariablePtr clip_grad_by_norm(CgVariablePtr x, float clip_norm, const vector<int> & axes);

NBLA_API vector<CgVariablePtr> sum(Context &ctx, CgVariablePtr x, const vector<int> & axes, bool keep_dims);
NBLA_API CgVariablePtr sum(CgVariablePtr x, const vector<int> & axes, bool keep_dims);

NBLA_API vector<CgVariablePtr> cumsum(Context &ctx, CgVariablePtr x, int axis, bool exclusive, bool reverse);
NBLA_API CgVariablePtr cumsum(CgVariablePtr x, int axis, bool exclusive, bool reverse);

NBLA_API vector<CgVariablePtr> mean(Context &ctx, CgVariablePtr x, const vector<int> & axes, bool keep_dims);
NBLA_API CgVariablePtr mean(CgVariablePtr x, const vector<int> & axes, bool keep_dims);

NBLA_API vector<CgVariablePtr> max(Context &ctx, CgVariablePtr x, const vector<int> & axes, bool keep_dims, bool with_index, bool only_index);
NBLA_API CgVariablePtr max(CgVariablePtr x, const vector<int> & axes, bool keep_dims, bool with_index, bool only_index);

NBLA_API vector<CgVariablePtr> min(Context &ctx, CgVariablePtr x, const vector<int> & axes, bool keep_dims, bool with_index, bool only_index);
NBLA_API CgVariablePtr min(CgVariablePtr x, const vector<int> & axes, bool keep_dims, bool with_index, bool only_index);

NBLA_API vector<CgVariablePtr> norm(Context &ctx, CgVariablePtr x, float p, const vector<int> & axes, bool keep_dims);
NBLA_API CgVariablePtr norm(CgVariablePtr x, float p, const vector<int> & axes, bool keep_dims);

NBLA_API vector<CgVariablePtr> prod(Context &ctx, CgVariablePtr x, const vector<int> & axes, bool keep_dims);
NBLA_API CgVariablePtr prod(CgVariablePtr x, const vector<int> & axes, bool keep_dims);

NBLA_API vector<CgVariablePtr> cumprod(Context &ctx, CgVariablePtr x, int axis, bool exclusive, bool reverse);
NBLA_API CgVariablePtr cumprod(CgVariablePtr x, int axis, bool exclusive, bool reverse);

NBLA_API vector<CgVariablePtr> reduce_sum(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr reduce_sum(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> reduce_mean(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr reduce_mean(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> add2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr add2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> add_n(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr add_n(CgVariablePtr x);
NBLA_API vector<CgVariablePtr> add_n(Context &ctx, vector<CgVariablePtr> x);
NBLA_API CgVariablePtr add_n(vector<CgVariablePtr> x);

NBLA_API vector<CgVariablePtr> bc_add2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr bc_add2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> sub2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr sub2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> mul2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr mul2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> mul_n(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr mul_n(CgVariablePtr x);
NBLA_API vector<CgVariablePtr> mul_n(Context &ctx, vector<CgVariablePtr> x);
NBLA_API CgVariablePtr mul_n(vector<CgVariablePtr> x);

NBLA_API vector<CgVariablePtr> div2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr div2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> pow2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, bool inplace);
NBLA_API CgVariablePtr pow2(CgVariablePtr x0, CgVariablePtr x1, bool inplace);

NBLA_API vector<CgVariablePtr> add_scalar(Context &ctx, CgVariablePtr x, double val, bool inplace);
NBLA_API CgVariablePtr add_scalar(CgVariablePtr x, double val, bool inplace);

NBLA_API vector<CgVariablePtr> mul_scalar(Context &ctx, CgVariablePtr x, double val, bool inplace);
NBLA_API CgVariablePtr mul_scalar(CgVariablePtr x, double val, bool inplace);

NBLA_API vector<CgVariablePtr> pow_scalar(Context &ctx, CgVariablePtr x, double val, bool inplace);
NBLA_API CgVariablePtr pow_scalar(CgVariablePtr x, double val, bool inplace);

NBLA_API vector<CgVariablePtr> r_sub_scalar(Context &ctx, CgVariablePtr x, double val);
NBLA_API CgVariablePtr r_sub_scalar(CgVariablePtr x, double val);

NBLA_API vector<CgVariablePtr> r_div_scalar(Context &ctx, CgVariablePtr x, double val);
NBLA_API CgVariablePtr r_div_scalar(CgVariablePtr x, double val);

NBLA_API vector<CgVariablePtr> r_pow_scalar(Context &ctx, CgVariablePtr x, double val);
NBLA_API CgVariablePtr r_pow_scalar(CgVariablePtr x, double val);

NBLA_API vector<CgVariablePtr> sign(Context &ctx, CgVariablePtr x, float alpha);
NBLA_API CgVariablePtr sign(CgVariablePtr x, float alpha);

NBLA_API vector<CgVariablePtr> minimum2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr minimum2(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> maximum2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr maximum2(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> minimum_scalar(Context &ctx, CgVariablePtr x, double val);
NBLA_API CgVariablePtr minimum_scalar(CgVariablePtr x, double val);

NBLA_API vector<CgVariablePtr> maximum_scalar(Context &ctx, CgVariablePtr x, double val);
NBLA_API CgVariablePtr maximum_scalar(CgVariablePtr x, double val);

NBLA_API vector<CgVariablePtr> logical_and(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr logical_and(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> logical_or(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr logical_or(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> logical_xor(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr logical_xor(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> equal(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr equal(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> not_equal(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr not_equal(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> greater_equal(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr greater_equal(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> greater(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr greater(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> less_equal(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr less_equal(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> less(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr less(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> searchsorted(Context &ctx, CgVariablePtr sorted_sequence, CgVariablePtr values, bool right);
NBLA_API CgVariablePtr searchsorted(CgVariablePtr sorted_sequence, CgVariablePtr values, bool right);

NBLA_API vector<CgVariablePtr> logical_and_scalar(Context &ctx, CgVariablePtr x0, bool val);
NBLA_API CgVariablePtr logical_and_scalar(CgVariablePtr x0, bool val);

NBLA_API vector<CgVariablePtr> logical_or_scalar(Context &ctx, CgVariablePtr x0, bool val);
NBLA_API CgVariablePtr logical_or_scalar(CgVariablePtr x0, bool val);

NBLA_API vector<CgVariablePtr> logical_xor_scalar(Context &ctx, CgVariablePtr x0, bool val);
NBLA_API CgVariablePtr logical_xor_scalar(CgVariablePtr x0, bool val);

NBLA_API vector<CgVariablePtr> equal_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr equal_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> not_equal_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr not_equal_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> greater_equal_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr greater_equal_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> greater_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr greater_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> less_equal_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr less_equal_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> less_scalar(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr less_scalar(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> logical_not(Context &ctx, CgVariablePtr x0);
NBLA_API CgVariablePtr logical_not(CgVariablePtr x0);

NBLA_API vector<CgVariablePtr> isnan(Context &ctx, CgVariablePtr x0);
NBLA_API CgVariablePtr isnan(CgVariablePtr x0);

NBLA_API vector<CgVariablePtr> isinf(Context &ctx, CgVariablePtr x0);
NBLA_API CgVariablePtr isinf(CgVariablePtr x0);

NBLA_API vector<CgVariablePtr> reset_nan(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr reset_nan(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> reset_inf(Context &ctx, CgVariablePtr x0, double val);
NBLA_API CgVariablePtr reset_inf(CgVariablePtr x0, double val);

NBLA_API vector<CgVariablePtr> where(Context &ctx, CgVariablePtr condition, CgVariablePtr x_true, CgVariablePtr x_false);
NBLA_API CgVariablePtr where(CgVariablePtr condition, CgVariablePtr x_true, CgVariablePtr x_false);

NBLA_API vector<CgVariablePtr> constant(Context &ctx, float val, const vector<int> & shape);
NBLA_API CgVariablePtr constant(float val, const vector<int> & shape);

NBLA_API vector<CgVariablePtr> arange(Context &ctx, float start, float stop, float step);
NBLA_API CgVariablePtr arange(float start, float stop, float step);

NBLA_API vector<CgVariablePtr> linspace(Context &ctx, float start, float stop, int num);
NBLA_API CgVariablePtr linspace(float start, float stop, int num);

NBLA_API vector<CgVariablePtr> abs(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr abs(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> exp(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr exp(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> log(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr log(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> identity(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr identity(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> batch_matmul(Context &ctx, CgVariablePtr a, CgVariablePtr b, bool transpose_a, bool transpose_b);
NBLA_API CgVariablePtr batch_matmul(CgVariablePtr a, CgVariablePtr b, bool transpose_a, bool transpose_b);

NBLA_API vector<CgVariablePtr> round(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr round(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> ceil(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr ceil(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> floor(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr floor(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> sin(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr sin(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> cos(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr cos(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> tan(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr tan(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> sinh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr sinh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> cosh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr cosh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> asin(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr asin(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> acos(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr acos(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> atan(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr atan(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> atan2(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr atan2(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> asinh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr asinh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> acosh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr acosh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> atanh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr atanh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> concatenate(Context &ctx, CgVariablePtr x, int axis);
NBLA_API CgVariablePtr concatenate(CgVariablePtr x, int axis);
NBLA_API vector<CgVariablePtr> concatenate(Context &ctx, vector<CgVariablePtr> x, int axis);
NBLA_API CgVariablePtr concatenate(vector<CgVariablePtr> x, int axis);

NBLA_API vector<CgVariablePtr> split(Context &ctx, CgVariablePtr x, int axis);
NBLA_API vector<CgVariablePtr> split(CgVariablePtr x, int axis);

NBLA_API vector<CgVariablePtr> stack(Context &ctx, CgVariablePtr x, int axis);
NBLA_API CgVariablePtr stack(CgVariablePtr x, int axis);
NBLA_API vector<CgVariablePtr> stack(Context &ctx, vector<CgVariablePtr> x, int axis);
NBLA_API CgVariablePtr stack(vector<CgVariablePtr> x, int axis);

NBLA_API vector<CgVariablePtr> slice(Context &ctx, CgVariablePtr x, const vector<int> & start, const vector<int> & stop, const vector<int> & step);
NBLA_API CgVariablePtr slice(CgVariablePtr x, const vector<int> & start, const vector<int> & stop, const vector<int> & step);

NBLA_API vector<CgVariablePtr> pad(Context &ctx, CgVariablePtr x, const vector<int> & pad_width, const string & mode, float constant_value);
NBLA_API CgVariablePtr pad(CgVariablePtr x, const vector<int> & pad_width, const string & mode, float constant_value);

NBLA_API vector<CgVariablePtr> transpose(Context &ctx, CgVariablePtr x, const vector<int> & axes);
NBLA_API CgVariablePtr transpose(CgVariablePtr x, const vector<int> & axes);

NBLA_API vector<CgVariablePtr> broadcast(Context &ctx, CgVariablePtr x, const vector<int> & shape);
NBLA_API CgVariablePtr broadcast(CgVariablePtr x, const vector<int> & shape);

NBLA_API vector<CgVariablePtr> broadcast_to(Context &ctx, CgVariablePtr x, CgVariablePtr y, int axis);
NBLA_API CgVariablePtr broadcast_to(CgVariablePtr x, CgVariablePtr y, int axis);

NBLA_API vector<CgVariablePtr> tile(Context &ctx, CgVariablePtr x, const vector<int> & reps);
NBLA_API CgVariablePtr tile(CgVariablePtr x, const vector<int> & reps);

NBLA_API vector<CgVariablePtr> one_hot(Context &ctx, CgVariablePtr x, const vector<int> & shape);
NBLA_API CgVariablePtr one_hot(CgVariablePtr x, const vector<int> & shape);

NBLA_API vector<CgVariablePtr> flip(Context &ctx, CgVariablePtr x, const vector<int> & axes);
NBLA_API CgVariablePtr flip(CgVariablePtr x, const vector<int> & axes);

NBLA_API vector<CgVariablePtr> shift(Context &ctx, CgVariablePtr x, const vector<int> & shifts, const string & border_mode);
NBLA_API CgVariablePtr shift(CgVariablePtr x, const vector<int> & shifts, const string & border_mode);

NBLA_API vector<CgVariablePtr> sort(Context &ctx, CgVariablePtr x, int axis, bool reverse, bool with_index, bool only_index);
NBLA_API vector<CgVariablePtr> sort(CgVariablePtr x, int axis, bool reverse, bool with_index, bool only_index);

NBLA_API vector<CgVariablePtr> reshape(Context &ctx, CgVariablePtr x, const vector<int> & shape, bool inplace);
NBLA_API CgVariablePtr reshape(CgVariablePtr x, const vector<int> & shape, bool inplace);

NBLA_API vector<CgVariablePtr> matrix_diag(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr matrix_diag(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> matrix_diag_part(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr matrix_diag_part(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> meshgrid(Context &ctx, CgVariablePtr x, bool ij_indexing);
NBLA_API CgVariablePtr meshgrid(CgVariablePtr x, bool ij_indexing);
NBLA_API vector<CgVariablePtr> meshgrid(Context &ctx, vector<CgVariablePtr> x, bool ij_indexing);
NBLA_API CgVariablePtr meshgrid(vector<CgVariablePtr> x, bool ij_indexing);

NBLA_API vector<CgVariablePtr> batch_det(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr batch_det(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> batch_inv(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr batch_inv(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> batch_logdet(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr batch_logdet(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> assign(Context &ctx, CgVariablePtr dst, CgVariablePtr src);
NBLA_API CgVariablePtr assign(CgVariablePtr dst, CgVariablePtr src);

NBLA_API vector<CgVariablePtr> gather(Context &ctx, CgVariablePtr x, CgVariablePtr Indices, int axis, int batch_dims);
NBLA_API CgVariablePtr gather(CgVariablePtr x, CgVariablePtr Indices, int axis, int batch_dims);

NBLA_API vector<CgVariablePtr> gather_nd(Context &ctx, CgVariablePtr x, CgVariablePtr indices);
NBLA_API CgVariablePtr gather_nd(CgVariablePtr x, CgVariablePtr indices);

NBLA_API vector<CgVariablePtr> bool_gather(Context &ctx, CgVariablePtr input, CgVariablePtr mask);
NBLA_API CgVariablePtr bool_gather(CgVariablePtr input, CgVariablePtr mask);

NBLA_API vector<CgVariablePtr> scatter_nd(Context &ctx, CgVariablePtr data, CgVariablePtr indices, CgVariablePtr out, const vector<int> & shape, bool add);
NBLA_API CgVariablePtr scatter_nd(CgVariablePtr data, CgVariablePtr indices, CgVariablePtr out, const vector<int> & shape, bool add);

NBLA_API vector<CgVariablePtr> scatter_add(Context &ctx, CgVariablePtr x0, CgVariablePtr indices, CgVariablePtr x1, int axis);
NBLA_API CgVariablePtr scatter_add(CgVariablePtr x0, CgVariablePtr indices, CgVariablePtr x1, int axis);

NBLA_API vector<CgVariablePtr> bool_scatter(Context &ctx, CgVariablePtr input, CgVariablePtr mask, CgVariablePtr output);
NBLA_API CgVariablePtr bool_scatter(CgVariablePtr input, CgVariablePtr mask, CgVariablePtr output);

NBLA_API vector<CgVariablePtr> bool_fill(Context &ctx, CgVariablePtr data, CgVariablePtr mask, float value);
NBLA_API CgVariablePtr bool_fill(CgVariablePtr data, CgVariablePtr mask, float value);

NBLA_API vector<CgVariablePtr> pack_padded_sequence(Context &ctx, CgVariablePtr padded_sequence, CgVariablePtr lengths, bool batch_first);
NBLA_API CgVariablePtr pack_padded_sequence(CgVariablePtr padded_sequence, CgVariablePtr lengths, bool batch_first);

NBLA_API vector<CgVariablePtr> pad_packed_sequence(Context &ctx, CgVariablePtr packed_sequence, CgVariablePtr batch_sizes, bool batch_first, float padding_value, int total_length);
NBLA_API CgVariablePtr pad_packed_sequence(CgVariablePtr packed_sequence, CgVariablePtr batch_sizes, bool batch_first, float padding_value, int total_length);

NBLA_API vector<CgVariablePtr> interpolate(Context &ctx, CgVariablePtr x, const vector<int> & output_size, const string & mode, bool align_corners, bool half_pixel, bool half_pixel_for_nn, bool channel_last);
NBLA_API CgVariablePtr interpolate(CgVariablePtr x, const vector<int> & output_size, const string & mode, bool align_corners, bool half_pixel, bool half_pixel_for_nn, bool channel_last);

NBLA_API vector<CgVariablePtr> fft(Context &ctx, CgVariablePtr x, int signal_ndim, bool normalized);
NBLA_API CgVariablePtr fft(CgVariablePtr x, int signal_ndim, bool normalized);

NBLA_API vector<CgVariablePtr> ifft(Context &ctx, CgVariablePtr x, int signal_ndim, bool normalized);
NBLA_API CgVariablePtr ifft(CgVariablePtr x, int signal_ndim, bool normalized);

NBLA_API vector<CgVariablePtr> stft(Context &ctx, CgVariablePtr x, int window_size, int stride, int fft_size, const string & window_type, bool center, const string & pad_mode, bool as_istft_backward);
NBLA_API CgVariablePtr stft(CgVariablePtr x, int window_size, int stride, int fft_size, const string & window_type, bool center, const string & pad_mode, bool as_istft_backward);

NBLA_API vector<CgVariablePtr> istft(Context &ctx, CgVariablePtr y_r, CgVariablePtr y_i, int window_size, int stride, int fft_size, const string & window_type, bool center, const string & pad_mode, bool as_stft_backward);
NBLA_API CgVariablePtr istft(CgVariablePtr y_r, CgVariablePtr y_i, int window_size, int stride, int fft_size, const string & window_type, bool center, const string & pad_mode, bool as_stft_backward);

NBLA_API vector<CgVariablePtr> dropout(Context &ctx, CgVariablePtr x, double p, int seed);
NBLA_API CgVariablePtr dropout(CgVariablePtr x, double p, int seed);

NBLA_API vector<CgVariablePtr> top_k_data(Context &ctx, CgVariablePtr x, int k, bool abs, bool reduce, int base_axis);
NBLA_API CgVariablePtr top_k_data(CgVariablePtr x, int k, bool abs, bool reduce, int base_axis);

NBLA_API vector<CgVariablePtr> top_k_grad(Context &ctx, CgVariablePtr x, int k, bool abs, int base_axis);
NBLA_API CgVariablePtr top_k_grad(CgVariablePtr x, int k, bool abs, int base_axis);

NBLA_API vector<CgVariablePtr> rand(Context &ctx, float low, float high, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr rand(float low, float high, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> randint(Context &ctx, int low, int high, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr randint(int low, int high, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> randn(Context &ctx, float mu, float sigma, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr randn(float mu, float sigma, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> rand_binomial(Context &ctx, int n, float p, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr rand_binomial(int n, float p, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> rand_beta(Context &ctx, float alpha, float beta, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr rand_beta(float alpha, float beta, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> rand_gamma(Context &ctx, float k, float theta, const vector<int> & shape, int seed);
NBLA_API CgVariablePtr rand_gamma(float k, float theta, const vector<int> & shape, int seed);

NBLA_API vector<CgVariablePtr> random_choice(Context &ctx, CgVariablePtr x, CgVariablePtr w, const vector<int> & shape, bool replace, int seed);
NBLA_API CgVariablePtr random_choice(CgVariablePtr x, CgVariablePtr w, const vector<int> & shape, bool replace, int seed);

NBLA_API vector<CgVariablePtr> random_crop(Context &ctx, CgVariablePtr x, const vector<int> & shape, int base_axis, int seed);
NBLA_API CgVariablePtr random_crop(CgVariablePtr x, const vector<int> & shape, int base_axis, int seed);

NBLA_API vector<CgVariablePtr> random_flip(Context &ctx, CgVariablePtr x, const vector<int> & axes, int base_axis, int seed);
NBLA_API CgVariablePtr random_flip(CgVariablePtr x, const vector<int> & axes, int base_axis, int seed);

NBLA_API vector<CgVariablePtr> random_shift(Context &ctx, CgVariablePtr x, const vector<int> & shifts, const string & border_mode, float constant_value, int base_axis, int seed);
NBLA_API CgVariablePtr random_shift(CgVariablePtr x, const vector<int> & shifts, const string & border_mode, float constant_value, int base_axis, int seed);

NBLA_API vector<CgVariablePtr> random_erase(Context &ctx, CgVariablePtr x, float prob, const vector<float> & area_ratios, const vector<float> & aspect_ratios, const vector<float> & replacements, int n, bool share, bool inplace, int base_axis, int seed, bool channel_last, bool ste_fine_grained);
NBLA_API CgVariablePtr random_erase(CgVariablePtr x, float prob, const vector<float> & area_ratios, const vector<float> & aspect_ratios, const vector<float> & replacements, int n, bool share, bool inplace, int base_axis, int seed, bool channel_last, bool ste_fine_grained);

NBLA_API vector<CgVariablePtr> image_augmentation(Context &ctx, CgVariablePtr x, const vector<int> & shape, const vector<int> & pad, float min_scale, float max_scale, float angle, float aspect_ratio, float distortion, bool flip_lr, bool flip_ud, float brightness, bool brightness_each, float contrast, float contrast_center, bool contrast_each, float noise, int seed);
NBLA_API CgVariablePtr image_augmentation(CgVariablePtr x, const vector<int> & shape, const vector<int> & pad, float min_scale, float max_scale, float angle, float aspect_ratio, float distortion, bool flip_lr, bool flip_ud, float brightness, bool brightness_each, float contrast, float contrast_center, bool contrast_each, float noise, int seed);

NBLA_API vector<CgVariablePtr> sigmoid_cross_entropy(Context &ctx, CgVariablePtr x, CgVariablePtr target);
NBLA_API CgVariablePtr sigmoid_cross_entropy(CgVariablePtr x, CgVariablePtr target);

NBLA_API vector<CgVariablePtr> binary_cross_entropy(Context &ctx, CgVariablePtr x, CgVariablePtr target);
NBLA_API CgVariablePtr binary_cross_entropy(CgVariablePtr x, CgVariablePtr target);

NBLA_API vector<CgVariablePtr> softmax_cross_entropy(Context &ctx, CgVariablePtr x, CgVariablePtr target, int axis);
NBLA_API CgVariablePtr softmax_cross_entropy(CgVariablePtr x, CgVariablePtr target, int axis);

NBLA_API vector<CgVariablePtr> categorical_cross_entropy(Context &ctx, CgVariablePtr x, CgVariablePtr target, int axis);
NBLA_API CgVariablePtr categorical_cross_entropy(CgVariablePtr x, CgVariablePtr target, int axis);

NBLA_API vector<CgVariablePtr> squared_error(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr squared_error(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> absolute_error(Context &ctx, CgVariablePtr x0, CgVariablePtr x1);
NBLA_API CgVariablePtr absolute_error(CgVariablePtr x0, CgVariablePtr x1);

NBLA_API vector<CgVariablePtr> huber_loss(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, float delta);
NBLA_API CgVariablePtr huber_loss(CgVariablePtr x0, CgVariablePtr x1, float delta);

NBLA_API vector<CgVariablePtr> epsilon_insensitive_loss(Context &ctx, CgVariablePtr x0, CgVariablePtr x1, float epsilon);
NBLA_API CgVariablePtr epsilon_insensitive_loss(CgVariablePtr x0, CgVariablePtr x1, float epsilon);

NBLA_API vector<CgVariablePtr> kl_multinomial(Context &ctx, CgVariablePtr p, CgVariablePtr q, int base_axis);
NBLA_API CgVariablePtr kl_multinomial(CgVariablePtr p, CgVariablePtr q, int base_axis);

NBLA_API vector<CgVariablePtr> affine_grid(Context &ctx, CgVariablePtr theta, const vector<int> & size, bool align_corners);
NBLA_API CgVariablePtr affine_grid(CgVariablePtr theta, const vector<int> & size, bool align_corners);

NBLA_API vector<CgVariablePtr> warp_by_grid(Context &ctx, CgVariablePtr x, CgVariablePtr grid, const string & mode, const string & padding_mode, bool align_corners, bool channel_last);
NBLA_API CgVariablePtr warp_by_grid(CgVariablePtr x, CgVariablePtr grid, const string & mode, const string & padding_mode, bool align_corners, bool channel_last);

NBLA_API vector<CgVariablePtr> warp_by_flow(Context &ctx, CgVariablePtr data, CgVariablePtr flow);
NBLA_API CgVariablePtr warp_by_flow(CgVariablePtr data, CgVariablePtr flow);

NBLA_API vector<CgVariablePtr> binary_sigmoid(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr binary_sigmoid(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> binary_tanh(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr binary_tanh(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> binary_connect_affine(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr bias, int base_axis, float quantize_zero_to);
NBLA_API CgVariablePtr binary_connect_affine(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr bias, int base_axis, float quantize_zero_to);

NBLA_API vector<CgVariablePtr> binary_connect_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, float quantize_zero_to);
NBLA_API CgVariablePtr binary_connect_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, float quantize_zero_to);

NBLA_API vector<CgVariablePtr> binary_weight_affine(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr alpha, CgVariablePtr bias, int base_axis, float quantize_zero_to);
NBLA_API CgVariablePtr binary_weight_affine(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr alpha, CgVariablePtr bias, int base_axis, float quantize_zero_to);

NBLA_API vector<CgVariablePtr> binary_weight_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr alpha, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, float quantize_zero_to);
NBLA_API CgVariablePtr binary_weight_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr binary_weight, CgVariablePtr alpha, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, float quantize_zero_to);

NBLA_API vector<CgVariablePtr> inq_affine(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr indicator_fixedweights, CgVariablePtr bias, int base_axis, int num_bits, const vector<int> & inq_iterations, const string & selection_algorithm, int seed);
NBLA_API CgVariablePtr inq_affine(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr indicator_fixedweights, CgVariablePtr bias, int base_axis, int num_bits, const vector<int> & inq_iterations, const string & selection_algorithm, int seed);

NBLA_API vector<CgVariablePtr> inq_convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr indicator_fixedweights, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, int num_bits, const vector<int> & inq_iterations, const string & selection_algorithm, int seed);
NBLA_API CgVariablePtr inq_convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr indicator_fixedweights, CgVariablePtr bias, int base_axis, const vector<int> & pad, const vector<int> & stride, const vector<int> & dilation, int group, int num_bits, const vector<int> & inq_iterations, const string & selection_algorithm, int seed);

NBLA_API vector<CgVariablePtr> fixed_point_quantize(Context &ctx, CgVariablePtr x, bool sign, int n, float delta, bool ste_fine_grained);
NBLA_API CgVariablePtr fixed_point_quantize(CgVariablePtr x, bool sign, int n, float delta, bool ste_fine_grained);

NBLA_API vector<CgVariablePtr> min_max_quantize(Context &ctx, CgVariablePtr x, CgVariablePtr qr_min, CgVariablePtr qr_max, CgVariablePtr ql_min, CgVariablePtr ql_max, float decay, bool x_min_max, bool ema, bool ste_fine_grained, float eps);
NBLA_API CgVariablePtr min_max_quantize(CgVariablePtr x, CgVariablePtr qr_min, CgVariablePtr qr_max, CgVariablePtr ql_min, CgVariablePtr ql_max, float decay, bool x_min_max, bool ema, bool ste_fine_grained, float eps);

NBLA_API vector<CgVariablePtr> pow2_quantize(Context &ctx, CgVariablePtr x, bool sign, bool with_zero, int n, int m, bool ste_fine_grained);
NBLA_API CgVariablePtr pow2_quantize(CgVariablePtr x, bool sign, bool with_zero, int n, int m, bool ste_fine_grained);

NBLA_API vector<CgVariablePtr> prune(Context &ctx, CgVariablePtr x, float rate);
NBLA_API CgVariablePtr prune(CgVariablePtr x, float rate);

NBLA_API vector<CgVariablePtr> quantize_linear(Context &ctx, CgVariablePtr x, CgVariablePtr scale, CgVariablePtr zero_point, const string & round_mode, bool narrow_range, int dtype);
NBLA_API CgVariablePtr quantize_linear(CgVariablePtr x, CgVariablePtr scale, CgVariablePtr zero_point, const string & round_mode, bool narrow_range, int dtype);

NBLA_API vector<CgVariablePtr> dequantize_linear(Context &ctx, CgVariablePtr x, CgVariablePtr scale, CgVariablePtr zero_point);
NBLA_API CgVariablePtr dequantize_linear(CgVariablePtr x, CgVariablePtr scale, CgVariablePtr zero_point);

NBLA_API vector<CgVariablePtr> top_n_error(Context &ctx, CgVariablePtr x, CgVariablePtr target, int axis, int n);
NBLA_API CgVariablePtr top_n_error(CgVariablePtr x, CgVariablePtr target, int axis, int n);

NBLA_API vector<CgVariablePtr> binary_error(Context &ctx, CgVariablePtr x, CgVariablePtr target);
NBLA_API CgVariablePtr binary_error(CgVariablePtr x, CgVariablePtr target);

NBLA_API vector<CgVariablePtr> confusion_matrix(Context &ctx, CgVariablePtr x, CgVariablePtr target, int axis);
NBLA_API CgVariablePtr confusion_matrix(CgVariablePtr x, CgVariablePtr target, int axis);

NBLA_API vector<CgVariablePtr> vat_noise(Context &ctx, CgVariablePtr x, CgVariablePtr w, int base_axis, float eps);
NBLA_API CgVariablePtr vat_noise(CgVariablePtr x, CgVariablePtr w, int base_axis, float eps);

NBLA_API vector<CgVariablePtr> unlink(Context &ctx, CgVariablePtr x);
NBLA_API CgVariablePtr unlink(CgVariablePtr x);

NBLA_API vector<CgVariablePtr> sink(Context &ctx, CgVariablePtr x, bool one_input_grad);
NBLA_API CgVariablePtr sink(CgVariablePtr x, bool one_input_grad);
NBLA_API vector<CgVariablePtr> sink(Context &ctx, vector<CgVariablePtr> x, bool one_input_grad);
NBLA_API CgVariablePtr sink(vector<CgVariablePtr> x, bool one_input_grad);

NBLA_API vector<CgVariablePtr> nms_detection2d(Context &ctx, CgVariablePtr x, float thresh, float nms, bool nms_per_class);
NBLA_API CgVariablePtr nms_detection2d(CgVariablePtr x, float thresh, float nms, bool nms_per_class);

NBLA_API vector<CgVariablePtr> max_pooling_backward(Context &ctx, CgVariablePtr dy, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);
NBLA_API CgVariablePtr max_pooling_backward(CgVariablePtr dy, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, bool ignore_border, const vector<int> & pad, bool channel_last);

NBLA_API vector<CgVariablePtr> patch_correlation(Context &ctx, CgVariablePtr x1, CgVariablePtr x2, const vector<int> & patch, const vector<int> & shift, const vector<int> & patch_step, const vector<int> & shift_step, const vector<int> & padding);
NBLA_API CgVariablePtr patch_correlation(CgVariablePtr x1, CgVariablePtr x2, const vector<int> & patch, const vector<int> & shift, const vector<int> & patch_step, const vector<int> & shift_step, const vector<int> & padding);

class NBLA_API ConvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
public:
  ConvolutionOpts();
  ConvolutionOpts &group(int val);
  ConvolutionOpts &pad(const vector<int> &val);
  ConvolutionOpts &stride(const vector<int> &val);
  ConvolutionOpts &dilation(const vector<int> &val);
  ConvolutionOpts &channel_last(bool val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
};

class NBLA_API DeconvolutionOpts {
private:
  int group_;
  vector<int> pad_;
  vector<int> stride_;
  vector<int> dilation_;
  bool channel_last_;
  vector<int> output_padding_;
public:
  DeconvolutionOpts();
  DeconvolutionOpts &group(int val);
  DeconvolutionOpts &pad(const vector<int> &val);
  DeconvolutionOpts &stride(const vector<int> &val);
  DeconvolutionOpts &dilation(const vector<int> &val);
  DeconvolutionOpts &channel_last(bool val);
  DeconvolutionOpts &output_padding(const vector<int> &val);
  int group() { return group_; };
  const vector<int> &pad() const { return pad_; };
  const vector<int> &stride() const { return stride_; };
  const vector<int> &dilation() const {return dilation_; };
  bool channel_last() const { return channel_last_; };
  const vector<int> &output_padding() const { return output_padding_; };
};

class NBLA_API BatchNormalizationOpts {
private:
  vector<int> axes_;
  float decay_rate_;
  float eps_;
public:
  BatchNormalizationOpts();
  BatchNormalizationOpts &axes(const vector<int> &val);
  BatchNormalizationOpts &decay_rate(float val);
  BatchNormalizationOpts &eps(float val);
  const vector<int> &axes() const;
  float decay_rate();
  float eps();
};

class NBLA_API PoolingOpts {
private:
  bool ignore_border_;
  bool including_pad_;
  vector<int> pad_;
  bool channel_last_;
public:
  PoolingOpts();
  PoolingOpts &ignore_border(bool ignore_border);
  PoolingOpts &including_pad(bool including_pad);
  PoolingOpts &pad(const vector<int> &val);
  PoolingOpts &channel_last(bool val);
  bool ignore_border() const;
  bool including_pad() const;
  const vector<int> &pad() const;
  bool channel_last() const;
};

NBLA_API vector<CgVariablePtr> convolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API vector<CgVariablePtr> deconvolution(Context &ctx, CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API vector<CgVariablePtr> batch_normalization(Context &ctx, CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API vector<CgVariablePtr> max_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> average_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API vector<CgVariablePtr> sum_pooling(Context &ctx, CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

NBLA_API CgVariablePtr convolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, ConvolutionOpts &conv_opts);
NBLA_API CgVariablePtr deconvolution(CgVariablePtr x, CgVariablePtr weight, CgVariablePtr bias, int base_axis, int group, DeconvolutionOpts &);
NBLA_API CgVariablePtr batch_normalization(CgVariablePtr x, CgVariablePtr beta, CgVariablePtr gamma, CgVariablePtr mean, CgVariablePtr variance, bool batch_stat, BatchNormalizationOpts batch_opts);
NBLA_API CgVariablePtr max_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr average_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());
NBLA_API CgVariablePtr sum_pooling(CgVariablePtr x, const vector<int> & kernel, const vector<int> & stride, PoolingOpts pooling_opts = PoolingOpts());

}
}

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const nbla::CgVariablePtr &b);

NBLA_API nbla::CgVariablePtr operator+(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator*(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator-(const nbla::CgVariablePtr &a, const float &b);
NBLA_API nbla::CgVariablePtr operator/(const nbla::CgVariablePtr &a, const float &b);

NBLA_API nbla::CgVariablePtr operator+(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator*(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator-(const float &a, const nbla::CgVariablePtr &b);
NBLA_API nbla::CgVariablePtr operator/(const float &a, const nbla::CgVariablePtr &b);
#endif
