// RUN: tf-mlir-translate -hlo-text-to-mlir-hlo -hlo-import-all-computations %s -o - | FileCheck %s

HloModule main
// CHECK-LABEL:  func @main(%arg0: tensor<f32>) -> tensor<f32> {
ENTRY %dummy_main (Arg_0.1: f32[]) -> f32[] {
  ROOT %Arg_0.1 = f32[] parameter(0)
}

// ----------------------
// To test that HLO computation block corresponding to cond and body of while
// loop are NOT modified when imported as individual functions.
// ----------------------
// CHECK-LABEL: func private @region_body1
// CHECK-SAME:    (%[[ARG_0:.*]]: tuple<tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>>) -> tuple<tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>>
// CHECK-NEXT:   %[[GTE_0:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 0
// CHECK-NEXT:   %[[GTE_1:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 1
// CHECK-NEXT:   %[[GTE_2:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 2
// CHECK-NEXT:   %[[GTE_3:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 3
// CHECK-NEXT:   %[[ADD:.*]] = mhlo.add %[[GTE_2]], %[[GTE_3]]
// CHECK-NEXT:   %[[RES:.*]] = "mhlo.tuple"(%[[GTE_0]], %[[GTE_1]], %[[GTE_2]], %[[ADD]])
// CHECK-NEXT:   return %[[RES]] : tuple<tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>>

%region_body1 (Arg_0.7: (s32[], s32[], f32[], f32[])) -> (s32[], s32[], f32[], f32[]) {
  %Arg_0.7 = (s32[], s32[], f32[], f32[]) parameter(0)
  %get-tuple-element.8 = s32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.7), index=0
  %get-tuple-element.9 = s32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.7), index=1
  %get-tuple-element.10 = f32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.7), index=2
  %get-tuple-element.11 = f32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.7), index=3
  %add.12 = f32[] add(f32[] %get-tuple-element.10, f32[] %get-tuple-element.11)
  ROOT %tuple.13 = (s32[], s32[], f32[], f32[]) tuple(s32[] %get-tuple-element.8, s32[] %get-tuple-element.9, f32[] %get-tuple-element.10, f32[] %add.12)
}

// ----------------------
// To test that HLO computation block corresponding to cond and body of while
// loop are NOT modified when imported as individual functions.
// ----------------------
// CHECK-LABEL: func private @region_cond1
// CHECK-SAME:    (%[[ARG_0:.*]]: tuple<tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>>) -> tensor<i1>
// CHECK-NEXT:   %[[CST:.*]] = mhlo.constant
// CHECK-NEXT:   %[[GTE_0:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 0
// CHECK-NEXT:   %[[GTE_1:.*]] = "mhlo.get_tuple_element"(%[[ARG_0]]) {index = 1
// CHECK-NEXT:   %[[CMP:.*]] = "mhlo.compare"(%[[GTE_0]], %[[GTE_1]])
// CHECK-NEXT"   return %[[CMP]] : tensor<i1>

%region_cond1 (Arg_0.15: (s32[], s32[], f32[], f32[])) -> pred[] {
  %constant.18 = s32[] constant(0)
  %Arg_0.15 = (s32[], s32[], f32[], f32[]) parameter(0)
  %get-tuple-element.16 = s32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.15), index=0
  %get-tuple-element.17 = s32[] get-tuple-element((s32[], s32[], f32[], f32[]) %Arg_0.15), index=1
  ROOT %compare.19 = pred[] compare(s32[] %get-tuple-element.16, s32[] %get-tuple-element.17), direction=LT
}

// ----------------------
// To test that
// 1. whileOp no more have tuple as ops or return types
// 2. The HLO computation block corresponding to cond and body of while loop are
//    modified when imported as region.
// ----------------------
// CHECK-LABEL: func private @test_1
// CHECK-SAME:    (%[[ARG_0:.*]]: tensor<f32>) -> tensor<f32> {
// CHECK-NEXT:   %[[CST_0:.*]] = mhlo.constant dense<0> : tensor<i32>
// CHECK-NEXT:   %[[CST_1:.*]] = mhlo.constant dense<100> : tensor<i32>
// CHECK-NEXT:   %[[CST_2:.*]] = mhlo.constant dense<1.000000e+00> : tensor<f32>
// CHECK-NEXT:   %[[WHILE:.*]]:4 = "mhlo.while"(%[[CST_0]], %[[CST_1]], %[[CST_2]], %[[ARG_0]]) ( {
// CHECK-NEXT:   ^bb0(%[[ARG_1:.*]]: tensor<i32>, %[[ARG_2:.*]]: tensor<i32>, %[[ARG_3:.*]]: tensor<f32>, [[ARG_4:.*]]: tensor<f32>):
// CHECK-NEXT:     %[[CST_3:.*]] = mhlo.constant
// CHECK-NEXT:     %[[CMP:.*]] = "mhlo.compare"(%[[ARG_1]], %[[ARG_2]])
// CHECK-NEXT:     "mhlo.return"(%[[CMP]]) : (tensor<i1>) -> ()
// CHECK-NEXT:   },  {
// CHECK-NEXT:   ^bb0(%[[ARG_5:.*]]: tensor<i32>, %[[ARG_6:.*]]: tensor<i32>, %[[ARG_7:.*]]: tensor<f32>, %[[ARG_8:.*]]: tensor<f32>):
// CHECK-NEXT:     %[[ADD:.*]] = mhlo.add %[[ARG_7]], %[[ARG_8]] : tensor<f32>
// CHECK-NEXT:     "mhlo.return"(%[[ARG_5]], %[[ARG_6]], %[[ARG_7]], %[[ADD]]) : (tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>) -> ()
// CHECK-NEXT:   })
// CHECK-SAME:       : (tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>) -> (tensor<i32>, tensor<i32>, tensor<f32>, tensor<f32>)
// CHECK-NEXT:   return %[[WHILE]]#3 : tensor<f32>
%test_1 (Arg_0.1: f32[]) -> f32[] {
  %constant.2 = s32[] constant(0)
  %constant.3 = s32[] constant(100)
  %constant.4 = f32[] constant(1)
  %Arg_0.1 = f32[] parameter(0)
  %tuple.5 = (s32[], s32[], f32[], f32[]) tuple(s32[] %constant.2, s32[] %constant.3, f32[] %constant.4, f32[] %Arg_0.1)
  %while.20 = (s32[], s32[], f32[], f32[]) while((s32[], s32[], f32[], f32[]) %tuple.5), condition=%region_cond1, body=%region_body1
  ROOT %get-tuple-element.21 = f32[] get-tuple-element((s32[], s32[], f32[], f32[]) %while.20), index=3
}

// ----------------------
// Test using mixed typed tuples
// ----------------------
%reduce_helper_add {
  lhs = s32[] parameter(0)
  rhs = s32[] parameter(1)
  ROOT add = s32[] add(lhs, rhs)
}

%region_body2 (Arg_0: ((s32[1], s32[2]), (f32[1], f32[3]))) -> ((s32[1], s32[2]), (f32[1], f32[3])) {
  %Arg_0 = ((s32[1], s32[2]), (f32[1], f32[3])) parameter(0)

  %get-tuple-element.1 = (s32[1], s32[2]) get-tuple-element(((s32[1], s32[2]), (f32[1], f32[3])) %Arg_0), index=0
  %get-tuple-element.2 = (f32[1], f32[3]) get-tuple-element(((s32[1], s32[2]), (f32[1], f32[3])) %Arg_0), index=1
  %get-tuple-element.3 = f32[1] get-tuple-element((f32[1], f32[3]) %get-tuple-element.2), index=0
  %get-tuple-element.4 = f32[3] get-tuple-element((f32[1], f32[3]) %get-tuple-element.2), index=1

  %broadcast.1 = f32[3] broadcast(f32[1] %get-tuple-element.3), dimensions={0}
  %add.1 = f32[3] add(f32[3] %get-tuple-element.4, f32[3] %broadcast.1)

  %tuple.1 = (f32[1], f32[3]) tuple(f32[1] %get-tuple-element.3, f32[3] %add.1)
  ROOT %tuple.2 = ((s32[1], s32[2]), (f32[1], f32[3])) tuple((s32[1], s32[2]) %get-tuple-element.1, (f32[1], f32[3]) %tuple.1)
}

%region_cond2 (Arg_0: ((s32[1], s32[2]), (f32[1], f32[3]))) -> pred[] {
  %constant.1 = s32[] constant(0)
  %Arg_0 = ((s32[1], s32[2]), (f32[1], f32[3])) parameter(0)
  %get-tuple-element.1 =  (s32[1], s32[2]) get-tuple-element(((s32[1], s32[2]), (f32[1], f32[3])) %Arg_0), index=0
  %get-tuple-element.2 =  s32[1] get-tuple-element((s32[1], s32[2]) %get-tuple-element.1), index=0
  %get-tuple-element.3 =  s32[2] get-tuple-element((s32[1], s32[2]) %get-tuple-element.1), index=1

  %reduce.1 = s32[] reduce(%get-tuple-element.2, %constant.1), dimensions={0}, to_apply=%reduce_helper_add
  %reduce.2 = s32[] reduce(%get-tuple-element.3, %constant.1), dimensions={0}, to_apply=%reduce_helper_add

  ROOT %compare.1 = pred[] compare(s32[] %reduce.1, s32[] %reduce.2), direction=LT
}

// CHECK-LABEL: func private @test_2
// CHECK-SAME:    (%[[ARG_0:.*]]: tensor<3xf32>) -> tensor<3xf32> {
// CHECK-NEXT:    %[[CST_0:.*]] = mhlo.constant dense<0> : tensor<1xi32>
// CHECK-NEXT:    %[[CST_1:.*]] = mhlo.constant dense<100> : tensor<2xi32>
// CHECK-NEXT:    %[[CST_2:.*]] = mhlo.constant dense<1.000000e+00> : tensor<1xf32>
// CHECK-NEXT:    %[[WHILE:.*]]:4 = "mhlo.while"(%[[CST_0]], %[[CST_1]], %[[CST_2]], %[[ARG_0]]) ( {
// CHECK-NEXT:    ^bb0(%[[COND_ARG1:.*]]: tensor<1xi32>, %[[COND_ARG2:.*]]: tensor<2xi32>, %[[COND_ARG3:.*]]: tensor<1xf32>, %[[COND_ARG4:.*]]: tensor<3xf32>):  // no predecessors
// CHECK-NEXT:      %[[CST_4:.*]] = mhlo.constant dense<0> : tensor<i32>
// CHECK-NEXT:      %[[RED_5:.*]] = mhlo.reduce %[[COND_ARG1]], %[[CST_4]]
// CHECK:           %[[RED_6:.*]] = mhlo.reduce %[[COND_ARG2]], %[[CST_4]]
// CHECK:           %[[CMP_7:.*]] = "mhlo.compare"(%[[RED_5]], %[[RED_6]]) {comparison_direction = "LT"} : (tensor<i32>, tensor<i32>) -> tensor<i1>
// CHECK-NEXT:      "mhlo.return"(%[[CMP_7]]) : (tensor<i1>) -> ()
// CHECK-NEXT:    },  {
// CHECK-NEXT:    ^bb0(%[[BODY_ARG1:.*]]: tensor<1xi32>, %[[BODY_ARG2:.*]]: tensor<2xi32>, %[[BODY_ARG3:.*]]: tensor<1xf32>, %[[BODY_ARG4:.*]]: tensor<3xf32>):  // no predecessors
// CHECK-NEXT:      %[[BDCAST_4:.*]] = "mhlo.broadcast_in_dim"(%arg3) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<3xf32>
// CHECK-NEXT:      %[[ADD_5:.*]] = mhlo.add %[[BODY_ARG4]], %[[BDCAST_4]] : tensor<3xf32>
// CHECK-NEXT:      "mhlo.return"(%[[BODY_ARG1]], %[[BODY_ARG2]], %[[BODY_ARG3]], %[[ADD_5]]) : (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>) -> ()
// CHECK-NEXT:    })
// CHECK_SAME:      : (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>) -> (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>)
// CHECK-NEXT:    return %[[WHILE]]#3 : tensor<3xf32>

%test_2 (Arg_0.1: f32[3]) -> f32[3] {
  %constant.2 = s32[1] constant({0})
  %constant.3 = s32[2] constant({100, 100})
  %constant.4 = f32[1] constant({1})
  %Arg_0.1 = f32[3] parameter(0)

  %tuple.1 = (s32[1], s32[2]) tuple(s32[1] %constant.2, s32[2] %constant.3)
  %tuple.2 = (f32[1], f32[3]) tuple(f32[1] %constant.4, f32[3] %Arg_0.1)
  %tuple.3 = ((s32[1], s32[2]), (f32[1], f32[3])) tuple((s32[1], s32[2]) %tuple.1, (f32[1], f32[3]) %tuple.2)

  %while.1 = ((s32[1], s32[2]), (f32[1], f32[3])) while(((s32[1], s32[2]), (f32[1], f32[3])) %tuple.3), condition=%region_cond2, body=%region_body2
  %get-tuple-element.1 = (f32[1], f32[3]) get-tuple-element(((s32[1], s32[2]), (f32[1], f32[3])) %while.1), index=1
  ROOT %get-tuple-element.2 = f32[3] get-tuple-element((f32[1], f32[3]) %get-tuple-element.1), index=1
}

// ----------------------
// Test using nested typed tuples.
// ----------------------
%region_body3 (Arg_0: (s32[1], (s32[2], (f32[1], (f32[3]))))) -> (s32[1], (s32[2], (f32[1], (f32[3])))) {
  %Arg_0 = (s32[1], (s32[2], (f32[1], (f32[3])))) parameter(0)

  %get-tuple-element.1 = s32[1] get-tuple-element((s32[1], (s32[2], (f32[1], (f32[3])))) %Arg_0), index=0
  %get-tuple-element.2 = (s32[2], (f32[1], (f32[3]))) get-tuple-element((s32[1], (s32[2], (f32[1], (f32[3])))) %Arg_0), index=1
  %get-tuple-element.3 = s32[2] get-tuple-element((s32[2], (f32[1], (f32[3]))) %get-tuple-element.2), index=0
  %get-tuple-element.4 = (f32[1], (f32[3])) get-tuple-element((s32[2], (f32[1], (f32[3]))) %get-tuple-element.2), index=1
  %get-tuple-element.5 = f32[1] get-tuple-element((f32[1], (f32[3])) %get-tuple-element.4), index=0
  %get-tuple-element.6 = (f32[3]) get-tuple-element((f32[1], (f32[3])) %get-tuple-element.4), index=1
  %get-tuple-element.7 = f32[3] get-tuple-element((f32[3]) %get-tuple-element.6), index=0

  %broadcast.1 = f32[3] broadcast(f32[1] %get-tuple-element.5), dimensions={0}
  %add.1 = f32[3] add(f32[3] %get-tuple-element.7, f32[3] %broadcast.1)

  %tuple.0 = (f32[3]) tuple(f32[3] %add.1)
  %tuple.1 = (f32[1], (f32[3])) tuple(f32[1] %get-tuple-element.5, (f32[3]) %tuple.0)
  %tuple.2 = (s32[2], (f32[1], (f32[3]))) tuple(s32[2] %get-tuple-element.3, (f32[1], (f32[3])) %tuple.1)
  ROOT %tuple.3 = (s32[1], (s32[2], (f32[1], (f32[3])))) tuple(s32[1] %get-tuple-element.1, (s32[2], (f32[1], (f32[3]))) %tuple.2)
}

%region_cond3 (Arg_0: (s32[1], (s32[2], (f32[1], (f32[3]))))) -> pred[] {
  %constant.1 = s32[] constant(0)
  %Arg_0 = (s32[1], (s32[2], (f32[1], (f32[3])))) parameter(0)

  %get-tuple-element.1 =  s32[1] get-tuple-element((s32[1], (s32[2], (f32[1], (f32[3])))) %Arg_0), index=0
  %get-tuple-element.2 =  (s32[2], (f32[1], (f32[3]))) get-tuple-element((s32[1], (s32[2], (f32[1], (f32[3])))) %Arg_0), index=1
  %get-tuple-element.3 =  s32[2] get-tuple-element((s32[2], (f32[1], (f32[3]))) %get-tuple-element.2), index=0

  %reduce.1 = s32[] reduce(%get-tuple-element.1, %constant.1), dimensions={0}, to_apply=%reduce_helper_add
  %reduce.2 = s32[] reduce(%get-tuple-element.3, %constant.1), dimensions={0}, to_apply=%reduce_helper_add

  ROOT %compare.1 = pred[] compare(s32[] %reduce.1, s32[] %reduce.2), direction=LT
}


// CHECK-LABEL: func private @test_3
// CHECK-SAME:    (%[[ARG_0:.*]]: tensor<3xf32>) -> tensor<3xf32> {
// CHECK-NEXT:    %[[CST_0:.*]] = mhlo.constant dense<0> : tensor<1xi32>
// CHECK-NEXT:    %[[CST_1:.*]] = mhlo.constant dense<100> : tensor<2xi32>
// CHECK-NEXT:    %[[CST_2:.*]] = mhlo.constant dense<1.000000e+00> : tensor<1xf32>
// CHECK-NEXT:    %[[WHILE:.*]]:4 = "mhlo.while"(%[[CST_0]], %[[CST_1]], %[[CST_2]], %[[ARG_0]]) ( {
// CHECK-NEXT:    ^bb0(%[[COND_ARG1:.*]]: tensor<1xi32>, %[[COND_ARG2:.*]]: tensor<2xi32>, %[[COND_ARG3:.*]]: tensor<1xf32>, %[[COND_ARG4:.*]]: tensor<3xf32>):  // no predecessors
// CHECK-NEXT:      %[[CST_4:.*]] = mhlo.constant dense<0> : tensor<i32>
// CHECK-NEXT:      %[[RED_5:.*]] = mhlo.reduce %[[COND_ARG1]], %[[CST_4]]
// CHECK:           %[[RED_6:.*]] = mhlo.reduce %[[COND_ARG2]], %[[CST_4]]
// CHECK:           %[[CMP_7:.*]] = "mhlo.compare"(%[[RED_5]], %[[RED_6]]) {comparison_direction = "LT"} : (tensor<i32>, tensor<i32>) -> tensor<i1>
// CHECK-NEXT:      "mhlo.return"(%[[CMP_7]]) : (tensor<i1>) -> ()
// CHECK-NEXT:    },  {
// CHECK-NEXT:    ^bb0(%[[BODY_ARG1:.*]]: tensor<1xi32>, %[[BODY_ARG2:.*]]: tensor<2xi32>, %[[BODY_ARG3:.*]]: tensor<1xf32>, %[[BODY_ARG4:.*]]: tensor<3xf32>):  // no predecessors
// CHECK-NEXT:      %[[BDCAST_4:.*]] = "mhlo.broadcast_in_dim"(%arg3) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<3xf32>
// CHECK-NEXT:      %[[ADD_5:.*]] = mhlo.add %[[BODY_ARG4]], %[[BDCAST_4]] : tensor<3xf32>
// CHECK-NEXT:      "mhlo.return"(%[[BODY_ARG1]], %[[BODY_ARG2]], %[[BODY_ARG3]], %[[ADD_5]]) : (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>) -> ()
// CHECK-NEXT:    })
// CHECK_SAME:      : (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>) -> (tensor<1xi32>, tensor<2xi32>, tensor<1xf32>, tensor<3xf32>)
// CHECK-NEXT:    return %[[WHILE]]#3 : tensor<3xf32>

%test_3 (Arg_0.1: f32[3]) -> f32[3] {

  %constant.0 = s32[1] constant({0})
  %constant.1 = s32[2] constant({100, 100})
  %constant.2 = f32[1] constant({1})
  %Arg_0.1 = f32[3] parameter(0)

  %tuple.0 = (f32[3]) tuple(f32[3] %Arg_0.1)
  %tuple.1 = (f32[1], (f32[3])) tuple(f32[1] %constant.2, (f32[3]) %tuple.0)
  %tuple.2 = (s32[2], (f32[1], (f32[3]))) tuple(s32[2] %constant.1, (f32[1], (f32[3])) %tuple.1)
  %tuple.3 = (s32[1], (s32[2], (f32[1], (f32[3])))) tuple(s32[1] %constant.0, (s32[2], (f32[1], (f32[3]))) %tuple.2)

  %while.1 = (s32[1], (s32[2], (f32[1], (f32[3])))) while((s32[1], (s32[2], (f32[1], (f32[3])))) %tuple.3), condition=%region_cond3, body=%region_body3
  %get-tuple-element.1 = (s32[2], (f32[1], (f32[3]))) get-tuple-element((s32[1], (s32[2], (f32[1], (f32[3])))) %while.1), index=1
  %get-tuple-element.2 = (f32[1], (f32[3])) get-tuple-element((s32[2], (f32[1], (f32[3]))) %get-tuple-element.1), index=1
  %get-tuple-element.3 = (f32[3]) get-tuple-element((f32[1], (f32[3])) %get-tuple-element.2), index=1
  ROOT %get-tuple-element.4 = f32[3] get-tuple-element((f32[3]) %get-tuple-element.3), index=0
}

// ----------------------
// Test using tuple operands of while
// ----------------------
%region_body4 (Arg_0: (s32[], (s32[], (s32[])))) -> (s32[], (s32[], (s32[]))) {
  %Arg_0 = (s32[], (s32[], (s32[]))) parameter(0)

  %get-tuple-element.1 =  s32[] get-tuple-element((s32[], (s32[], (s32[]))) %Arg_0), index=0
  %get-tuple-element.2 =  (s32[], (s32[])) get-tuple-element((s32[], (s32[], (s32[]))) %Arg_0), index=1
  %get-tuple-element.3 =  s32[] get-tuple-element((s32[], (s32[])) %get-tuple-element.2), index=0
  %get-tuple-element.4 =  (s32[]) get-tuple-element((s32[], (s32[])) %get-tuple-element.2), index=1
  %get-tuple-element.5 =  s32[] get-tuple-element((s32[]) %get-tuple-element.4), index=0

  %add.1 = s32[] add(s32[] %get-tuple-element.1, s32[] %get-tuple-element.3)

  ROOT %tuple.0 =  (s32[], (s32[], (s32[]))) tuple(s32[] %add.1, (s32[], (s32[])) %get-tuple-element.2)
}

%region_cond4 (Arg_0: (s32[], (s32[], (s32[])))) -> pred[] {
  %Arg_0 = (s32[], (s32[], (s32[]))) parameter(0)

  %get-tuple-element.1 =  s32[] get-tuple-element((s32[], (s32[], (s32[]))) %Arg_0), index=0
  %get-tuple-element.2 =  (s32[], (s32[])) get-tuple-element((s32[], (s32[], (s32[]))) %Arg_0), index=1
  %get-tuple-element.3 =  (s32[]) get-tuple-element((s32[], (s32[])) %get-tuple-element.2), index=1
  %get-tuple-element.4 =  s32[] get-tuple-element((s32[]) %get-tuple-element.3), index=0

  ROOT %compare.1 = pred[] compare(s32[] %get-tuple-element.1, s32[] %get-tuple-element.4), direction=LT
}

// CHECK-LABEL: func private @test_4
// CHECK-SAME:    (%[[ARG_0:.*]]: tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>) -> tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>
// CHECK-NEXT:    %[[GTE_0:.*]] = "mhlo.get_tuple_element"(%arg0) {index = 0 : i32} : (tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>) -> tensor<i32>
// CHECK-NEXT:    %[[GTE_1:.*]] = "mhlo.get_tuple_element"(%arg0) {index = 1 : i32} : (tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>) -> tuple<tensor<i32>, tuple<tensor<i32>>>
// CHECK-NEXT:    %[[GTE_2:.*]] = "mhlo.get_tuple_element"(%1) {index = 0 : i32} : (tuple<tensor<i32>, tuple<tensor<i32>>>) -> tensor<i32>
// CHECK-NEXT:    %[[GTE_3:.*]] = "mhlo.get_tuple_element"(%1) {index = 1 : i32} : (tuple<tensor<i32>, tuple<tensor<i32>>>) -> tuple<tensor<i32>>
// CHECK-NEXT:    %[[GTE_4:.*]] = "mhlo.get_tuple_element"(%3) {index = 0 : i32} : (tuple<tensor<i32>>) -> tensor<i32>
// CHECK-NEXT:    %[[WHILE:.*]]:3 = "mhlo.while"(%[[GTE_0]], %[[GTE_2]], %[[GTE_4]])
// CHECK-NEXT:    ^bb0(%[[COND_ARG1:.*]]: tensor<i32>, %[[COND_ARG2:.*]]: tensor<i32>, %[[COND_ARG3:.*]]: tensor<i32>):
// CHECK:           %[[CMP:.*]] = "mhlo.compare"(%[[COND_ARG1]], %[[COND_ARG3]]) {comparison_direction = "LT"} : (tensor<i32>, tensor<i32>) -> tensor<i1>
// CHECK-NEXT:      "mhlo.return"(%[[CMP]]) : (tensor<i1>) -> ()
// CHECK-NEXT:    },  {
// CHECK-NEXT:    ^bb0(%[[BODY_ARG1:.*]]: tensor<i32>, %[[BODY_ARG2:.*]]: tensor<i32>, %[[BODY_ARG3:.*]]: tensor<i32>):
// CHECK-NEXT:      %[[ADD:.*]] = mhlo.add %[[BODY_ARG1]], %[[BODY_ARG2]] : tensor<i32>
// CHECK-NEXT:      "mhlo.return"(%[[ADD]], %[[BODY_ARG2]], %[[BODY_ARG3]]) : (tensor<i32>, tensor<i32>, tensor<i32>) -> ()
// CHECK-NEXT:    })
// CHECK_SAME:      : (tensor<i32>, tensor<i32>, tensor<i32>) -> (tensor<i32>, tensor<i32>, tensor<i32>)
// CHECK-NEXT:    %[[TUPLE_6:.*]] = "mhlo.tuple"(%[[WHILE]]#2) : (tensor<i32>) -> tuple<tensor<i32>>
// CHECK-NEXT:    %[[TUPLE_7:.*]] = "mhlo.tuple"(%[[WHILE]]#1, %[[TUPLE_6]]) : (tensor<i32>, tuple<tensor<i32>>) -> tuple<tensor<i32>, tuple<tensor<i32>>>
// CHECK-NEXT:    %[[TUPLE_8:.*]] = "mhlo.tuple"(%[[WHILE]]#0, %[[TUPLE_7]]) {xla_shape = "(s32[], (s32[], (s32[])))"} : (tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>) -> tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>
// CHECK-NEXT:     return %[[TUPLE_8]] : tuple<tensor<i32>, tuple<tensor<i32>, tuple<tensor<i32>>>>

%test_4 (Arg_0: (s32[], (s32[], (s32[])))) -> (s32[], (s32[], (s32[]))) {
  %Arg_0 = (s32[], (s32[], (s32[]))) parameter(0)
  ROOT %while.1 = (s32[], (s32[], (s32[]))) while((s32[], (s32[], (s32[]))) %Arg_0), condition=%region_cond4, body=%region_body4
}

// ----------------------
// Test using tuple operands of while with one element
// ----------------------
region_body5 {
  constant.7 = pred[] constant(false)
  parameter.5 = (f32[3,3]{1,0}) parameter(0)
  get-tuple-element.6 = f32[3,3]{1,0} get-tuple-element(parameter.5), index=0
  constant.8 = f32[] constant(2)
  broadcast.9 = f32[3,3]{1,0} broadcast(constant.8), dimensions={}
  add.10 = f32[3,3]{1,0} add(get-tuple-element.6, broadcast.9)
  ROOT tuple.11 = (f32[3,3]{1,0}) tuple(add.10)
}

primitive_computation_add__1.12 {
  constant.15 = pred[] constant(false)
  parameter.13 = f32[] parameter(0)
  parameter.14 = f32[] parameter(1)
  ROOT add.16 = f32[] add(parameter.13, parameter.14)
}

region_cond5 {
  constant.20 = pred[] constant(false)
  parameter.18 = (f32[3,3]{1,0}) parameter(0)
  get-tuple-element.19 = f32[3,3]{1,0} get-tuple-element(parameter.18), index=0
  constant.21 = f32[] constant(0)
  reduce.22 = f32[] reduce(get-tuple-element.19, constant.21), dimensions={0,1}, to_apply=primitive_computation_add__1.12
  constant.23 = f32[] constant(100)
  ROOT compare.24 = pred[] compare(reduce.22, constant.23), direction=LT
}

// CHECK-LABEL: func private @test_5
// CHECK-SAME:    (%[[ARG_0:.*]]: tensor<3x3xf32>) -> tensor<3x3xf32>
// CHECK-NEXT:    %[[CST_0:.*]] = mhlo.constant dense<false> : tensor<i1>
// CHECK-NEXT:    %[[WHILE:.*]] = "mhlo.while"(%[[ARG_0]])
// CHECK-NEXT:    ^bb0(%[[ARG_1:.*]]: tensor<3x3xf32>):
// CHECK-NEXT:      %[[CST_2:.*]] = mhlo.constant dense<false> : tensor<i1>
// CHECK-NEXT:      %[[CST_3:.*]] = mhlo.constant dense<0.000000e+00> : tensor<f32>
// CHECK-NEXT:      %[[REDUCE:.*]] = mhlo.reduce %[[ARG_1]], %[[CST_3]] ( {
// CHECK-NEXT:      ^bb0(%[[ARG_2:.*]]: tensor<f32>, %[[ARG_3:.*]]: tensor<f32>):
// CHECK-NEXT:        mhlo.constant dense<false> : tensor<i1>
// CHECK-NEXT:        %[[ADD:.*]] = mhlo.add %[[ARG_2]], %[[ARG_3]] : tensor<f32>
// CHECK-NEXT:        "mhlo.return"(%[[ADD]]) : (tensor<f32>) -> ()
// CHECK-NEXT:      }) {dimensions = dense<[0, 1]> : tensor<2xi64>} : (tensor<3x3xf32>, tensor<f32>) -> tensor<f32>
// CHECK-NEXT:      %[[CST_4:.*]] = mhlo.constant dense<1.000000e+02> : tensor<f32>
// CHECK-NEXT:      %[[CMP:.*]] = "mhlo.compare"(%[[REDUCE]], %[[CST_4]]) {comparison_direction = "LT"} : (tensor<f32>, tensor<f32>) -> tensor<i1>
// CHECK-NEXT:      "mhlo.return"(%[[CMP]]) : (tensor<i1>) -> ()
// CHECK-NEXT:    },  {
// CHECK-NEXT:    ^bb0(%[[ARG_1:.*]]: tensor<3x3xf32>):
// CHECK-NEXT:      %[[CST_2:.*]] = mhlo.constant dense<false> : tensor<i1>
// CHECK-NEXT:      %[[CST_3:.*]] = mhlo.constant dense<2.000000e+00> : tensor<f32>
// CHECK-NEXT:      %[[BDCAST:.*]] = "mhlo.broadcast_in_dim"(%[[CST_3]]) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<f32>) -> tensor<3x3xf32>
// CHECK-NEXT:      %[[ADD:.*]] = mhlo.add %[[ARG_1]], %[[BDCAST]] : tensor<3x3xf32>
// CHECK-NEXT:      "mhlo.return"(%[[ADD]]) : (tensor<3x3xf32>) -> ()
// CHECK-NEXT:    }) : (tensor<3x3xf32>) -> tensor<3x3xf32>
// CHECK-NEXT:    return %[[WHILE]] : tensor<3x3xf32>

%test_5 {
  constant.2 = pred[] constant(false)
  parameter.1 = f32[3,3]{1,0} parameter(0)
  tuple.3 = (f32[3,3]{1,0}) tuple(parameter.1)
  while.25 = (f32[3,3]{1,0}) while(tuple.3), condition=region_cond5, body=region_body5
  ROOT get-tuple-element.26 = f32[3,3]{1,0} get-tuple-element(while.25), index=0
}

// ----------------------
// Test using custom-call with tuple-arg within while body
// ----------------------
%region_body6 (Arg_0: (s32[], s32[])) -> (s32[], s32[]) {
  %Arg_0 = (s32[], s32[]) parameter(0)
  %get-tuple-element.0 = s32[] get-tuple-element((s32[], s32[]) %Arg_0), index=0
  %get-tuple-element.1 = s32[] get-tuple-element((s32[], s32[]) %Arg_0), index=1
  ROOT %custom-call =  (s32[], s32[]) custom-call(s32[] %get-tuple-element.0, (s32[], s32[]) %Arg_0), custom_call_target="foo", backend_config="bar"
}

%region_cond6 (Arg_0: (s32[], s32[])) -> pred[] {
  %Arg_0 = (s32[], s32[]) parameter(0)
  %get-tuple-element.0 = s32[] get-tuple-element((s32[], s32[]) %Arg_0), index=0
  %get-tuple-element.1 = s32[] get-tuple-element((s32[], s32[]) %Arg_0), index=1
  ROOT %compare.0 = pred[] compare(s32[] %get-tuple-element.0, s32[] %get-tuple-element.1), direction=LT
}

// CHECK-LABEL: func private @test_6
// CHECK-SAME:   (%[[ARG_0:.*]]: tensor<i32>) -> tensor<i32>
// CHECK_NEXT:    %[[CST_0:.*]] = mhlo.constant dense<0> : tensor<i32>
// CHECK_NEXT:    %[[WHILE:.*]]:2 = "mhlo.while"(%[[CST_0]], %[[ARG_0]])
// CHECK_NEXT:    ^bb0(%[[ARG_1:.*]]: tensor<i32>, %[[ARG_2:.*]]: tensor<i32>):
// CHECK_NEXT:      %[[CMP:.*]] = "mhlo.compare"(%[[ARG_1]], %[[ARG_2]]) {comparison_direction = "LT"} : (tensor<i32>, tensor<i32>) -> tensor<i1>
// CHECK_NEXT:      "mhlo.return"(%[[CMP]]) : (tensor<i1>) -> ()
// CHECK_NEXT:    },  {
// CHECK_NEXT:    ^bb0(%[[ARG_1:.*]]: tensor<i32>, %[[ARG_2:.*]]: tensor<i32>):
// CHECK_NEXT:      %[[TUPLE:.*]] = "mhlo.tuple"(%ARG_1, %ARG_2) : (tensor<i32>, tensor<i32>) -> tuple<tensor<i32>, tensor<i32>>
// CHECK_NEXT:      %[CC:.*]] = "mhlo.custom_call"(%[[ARG_1]], %[[TUPLE]]) [[CONFIG:.*]] : (tensor<i32>, tuple<tensor<i32>, tensor<i32>>) -> tuple<tensor<i32>, tensor<i32>>
// CHECK_NEXT:      %[[GTE_0:.*]] = "mhlo.get_tuple_element"(%[[CC]]) {index = 0 : i32} : (tuple<tensor<i32>, tensor<i32>>) -> tensor<i32>
// CHECK_NEXT:      %[[GTE_1:.*]] = "mhlo.get_tuple_element"(%[[CC]]) {index = 1 : i32} : (tuple<tensor<i32>, tensor<i32>>) -> tensor<i32>
// CHECK_NEXT:      "mhlo.return"(%[[GTE_0]], %[[GTE_1]]) : (tensor<i32>, tensor<i32>) -> ()
// CHECK_NEXT:    }) : (tensor<i32>, tensor<i32>) -> (tensor<i32>, tensor<i32>)
// CHECK_NEXT:    return %[[WHILE]]#0 : tensor<i32>

%test_6 {
  %constant.0 = s32[] constant(0)
  %Arg_0 = s32[] parameter(0)
  %tuple.0 = (s32[], s32[]) tuple(s32[] %constant.0, s32[] %Arg_0)
  %while.0 = (s32[], s32[]) while((s32[], s32[]) %tuple.0), condition=%region_cond6, body=%region_body6
  ROOT %get-tuple-element.21 = s32[] get-tuple-element((s32[], s32[]) %while.0), index=0
}

